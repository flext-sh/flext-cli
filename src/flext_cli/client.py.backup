"""gRPC Client using Universal Interface - with strict validation."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any

import grpc

from flx_core.domain.advanced_types import ServiceError, ServiceResult
from flx_core.grpc.client import FlxGrpcClientBase
from flx_core.security.ssl_utils import _create_ssl_credentials
from flx_core.universe import get_universe, universal_grpc


@dataclass(frozen=True, slots=True)
class GetPipelineResponse:
    """Response model for pipeline retrieval operations."""

    id: str
    name: str
    status: str
    description: str | None = None
    config: dict[str, Any] | None = None
    created_at: str | None = None
    updated_at: str | None = None


class FlxCliGrpcClient(FlxGrpcClientBase):
    """FlxCliGrpcClient - CLI gRPC Client Implementation with Universal Interface.

    Extends the base gRPC client with CLI-specific functionality using
    the universal interface patterns for command execution.
    Renamed from FlxGrpcClient to avoid conflict with dashboard FlxGrpcClient.

    Provides gRPC client for communication with FLX services including
    pipeline management, monitoring, and administrative operations.

    Attributes:
    ----------
        server_address: gRPC server address and port.

    Methods:
    -------
        create_pipeline(): Create new pipeline instance
        execute_pipeline(): Execute main pipeline operation
        list_pipelines(): List available pipelines

    Examples:
    --------
        Basic usage of the class:

        ```python
        client = FlxGrpcClient()
        result = await client.create_pipeline(name="example")
        ```

    See Also:
    --------
        - [Architecture Documentation](../../docs/architecture/index.md)
        - [Design Patterns](../../docs/architecture/001-clean-architecture-ddd.md)

    Note:
    ----
        This class follows Enterprise Patterns established in the project.

    """

    def __init__(self, server_address: str | None = None, token: str | None = None) -> None:
        """Initialize CLI gRPC client with server address and authentication token."""
        super().__init__()
        if server_address:
            self.server_address = server_address
        else:
            # Use unified configuration from base class
            self.server_address = f"{self._config.network.grpc_host}:{self._config.network.grpc_port}"

        # Store authentication token for gRPC metadata
        self.auth_token = token
        self._channel = None
        self._stub: object = None

    async def connect(self) -> None:
        """Connect to the gRPC server and create stub."""
        if not self._channel:
            self._channel = self._create_channel()  # type: ignore[no-untyped-call]
            self._stub = self._create_stub(self._channel)  # type: ignore[assignment]

    async def disconnect(self) -> None:
        """Disconnect from the gRPC server."""
        if self._channel:
            self._channel.close()
            self._channel = None
            self._stub = None

    def _get_metadata(self) -> list[tuple[str, str]]:
        """Get gRPC metadata including authentication token."""
        metadata = []
        if self.auth_token:
            metadata.append(("authorization", self.auth_token))
        return metadata

    def _create_channel(self) -> grpc.Channel:  # type: ignore[no-any-unimported]
        """Create gRPC channel using instance server address."""
        options = self._get_channel_options()

        if self._config.network.enable_ssl:
            credentials = _create_ssl_credentials(
                cert_file=self._config.network.ssl_cert_file,
                key_file=self._config.network.ssl_key_file,
                ca_file=self._config.network.ssl_ca_file,
            )
            return grpc.secure_channel(self.server_address, credentials, options=options)
        return grpc.insecure_channel(self.server_address, options=options)

    async def create_pipeline(self, **kwargs: str | int | bool | None) -> ServiceResult[object]:
        """Create pipeline via gRPC using universal interface."""
        success, response = await universal_grpc("PipelineService", "CreatePipeline", dict(kwargs))

        if success:
            # Use cast to ensure dict type safety for response
            response_dict = response if isinstance(response, dict) else {}
            return ServiceResult.ok(response_dict.get("data"))

        # Use cast to ensure dict type safety for response
        response_dict = response if isinstance(response, dict) else {}
        error_data = response_dict.get("error", {})
        error_data_dict = error_data if isinstance(error_data, dict) else {}
        error = ServiceError(
            code=error_data_dict.get("code", "GRPC_ERROR"),
            message=error_data_dict.get("message", "gRPC call failed"),
        )
        return ServiceResult.fail(error)

    async def execute_pipeline(self, **kwargs: str | int | bool | None) -> ServiceResult[object]:
        """Execute pipeline using UNIFIED EXECUTION ARCHITECTURE - with strict validation."""
        # Import universe here to avoid circular dependencies
        try:
            # Use UNIFIED COMMAND UNIVERSE for gRPC client execution - ZERO TOLERANCE
            universe = await get_universe()

            # Delegate to unified execution with gRPC client parameters
            result = await universe.execute(
                command_name="execute_pipeline",
                parameters=dict(kwargs),  # Ensure proper dict[str, object] type
                context={
                    "service": "grpc_client",
                    "caller": self.__class__.__name__,
                    "server_address": self.server_address,
                    "protocol": "grpc_client",
                },
            )

            # Convert universe result to ServiceResult format
            if result.success:
                return ServiceResult.ok(result.data)
            error = result.error or ServiceError(code="GRPC_ERROR", message="Pipeline execution failed")
            return ServiceResult.fail(error)

        except (
            ValueError,
            TypeError,
            RuntimeError,
            OSError,
            ImportError,
            ConnectionError,
            TimeoutError,
            AttributeError,
            LookupError,
        ) as e:
            # ZERO TOLERANCE - Specific exception types for CLI client execution failures
            return ServiceResult.fail(ServiceError(code="EXECUTION_ERROR", message=f"Pipeline execution failed: {e}"))

    async def list_pipelines(self, **kwargs: str | int | bool | None) -> ServiceResult[object]:
        """List pipelines via gRPC using universal interface."""
        success, response = await universal_grpc("PipelineService", "ListPipelines", dict(kwargs))

        if success:
            # Use cast to ensure dict type safety for response
            response_dict = response if isinstance(response, dict) else {}
            return ServiceResult.ok(response_dict.get("data"))

        # Use cast to ensure dict type safety for response
        response_dict = response if isinstance(response, dict) else {}
        error_data = response_dict.get("error", {})
        error_data_dict = error_data if isinstance(error_data, dict) else {}
        error = ServiceError(
            code=error_data_dict.get("code", "GRPC_ERROR"),
            message=error_data_dict.get("message", "gRPC call failed"),
        )
        return ServiceResult.fail(error)


# Alias for compatibility
FlxClient = FlxCliGrpcClient
FlxGrpcClient = FlxCliGrpcClient  # Legacy alias
